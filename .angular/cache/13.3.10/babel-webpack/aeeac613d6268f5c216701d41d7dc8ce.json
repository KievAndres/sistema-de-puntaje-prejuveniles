{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport GoTrueAdminApi from './GoTrueAdminApi';\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, STORAGE_KEY } from './lib/constants';\nimport { AuthImplicitGrantRedirectError, AuthInvalidCredentialsError, AuthRetryableFetchError, AuthSessionMissingError, AuthUnknownError, isAuthApiError, isAuthError } from './lib/errors';\nimport { _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch';\nimport { decodeJWTPayload, Deferred, getItemAsync, getParameterByName, isBrowser, removeItemAsync, resolveFetch, setItemAsync, uuid, retryable, sleep } from './lib/helpers';\nimport localStorageAdapter from './lib/local-storage';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS\n};\n/** Current session will be checked for refresh at this interval. */\nconst AUTO_REFRESH_TICK_DURATION = 10 * 1000;\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */\nconst AUTO_REFRESH_TICK_THRESHOLD = 3;\nexport default class GoTrueClient {\n  /**\n   * Create a new client for use in the browser.\n   */\n  constructor(options) {\n    this.stateChangeEmitters = new Map();\n    this.autoRefreshTicker = null;\n    this.visibilityChangedCallback = null;\n    this.refreshingDeferred = null;\n    /**\n     * Keeps track of the async client initialization.\n     * When null or not yet resolved the auth state is `unknown`\n     * Once resolved the the auth state is known and it's save to call any further client methods.\n     * Keep extra care to never reject or throw uncaught errors\n     */\n    this.initializePromise = null;\n    this.detectSessionInUrl = true;\n    /**\n     * Used to broadcast state change events to other tabs listening.\n     */\n    this.broadcastChannel = null;\n    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.inMemorySession = null;\n    this.storageKey = settings.storageKey;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.storage = settings.storage || localStorageAdapter;\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch\n    });\n    this.url = settings.url;\n    this.headers = settings.headers;\n    this.fetch = resolveFetch(settings.fetch);\n    this.detectSessionInUrl = settings.detectSessionInUrl;\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)\n    };\n    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n      this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n      this.broadcastChannel.addEventListener('message', event => {\n        this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages\n      });\n    }\n\n    this.initialize();\n  }\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n  initialize() {\n    if (!this.initializePromise) {\n      this.initializePromise = this._initialize();\n    }\n    return this.initializePromise;\n  }\n  /**\n   * IMPORTANT:\n   * 1. Never throw in this method, as it is called from the constructor\n   * 2. Never return a session from this method as it would be cached over\n   *    the whole lifetime of the client\n   */\n  _initialize() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.initializePromise) {\n        return this.initializePromise;\n      }\n      try {\n        if (this.detectSessionInUrl && this._isImplicitGrantFlow()) {\n          const {\n            data,\n            error\n          } = yield this._getSessionFromUrl();\n          if (error) {\n            // failed login attempt via url,\n            // remove old session as in verifyOtp, signUp and signInWith*\n            yield this._removeSession();\n            return {\n              error\n            };\n          }\n          const {\n            session,\n            redirectType\n          } = data;\n          yield this._saveSession(session);\n          this._notifyAllSubscribers('SIGNED_IN', session);\n          if (redirectType === 'recovery') {\n            this._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n          }\n          return {\n            error: null\n          };\n        }\n        // no login attempt via callback url try to recover session from storage\n        yield this._recoverAndRefresh();\n        return {\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            error\n          };\n        }\n        return {\n          error: new AuthUnknownError('Unexpected error during initialization', error)\n        };\n      } finally {\n        yield this._handleVisibilityChange();\n      }\n    });\n  }\n  /**\n   * Creates a new user.\n   *\n   * Be aware that if a user account exists in the system you may get back an\n   * error message that attempts to hide this information from the user.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  signUp(credentials) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        let res;\n        if ('email' in credentials) {\n          const {\n            email,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n            headers: this.headers,\n            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n            body: {\n              email,\n              password,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else if ('phone' in credentials) {\n          const {\n            phone,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n            headers: this.headers,\n            body: {\n              phone,\n              password,\n              data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else {\n          throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n        }\n        const {\n          data,\n          error\n        } = res;\n        if (error || !data) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: error\n          };\n        }\n        const session = data.session;\n        const user = data.user;\n        if (data.session) {\n          yield this._saveSession(data.session);\n          this._notifyAllSubscribers('SIGNED_IN', session);\n        }\n        return {\n          data: {\n            user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Log in an existing user with an email and password or phone and password.\n   *\n   * Be aware that you may get back an error message that will not distingish\n   * between the cases where the account does not exist or that the\n   * email/phone and password combination is wrong or that the account can only\n   * be accessed via social login.\n   */\n  signInWithPassword(credentials) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        let res;\n        if ('email' in credentials) {\n          const {\n            email,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n            headers: this.headers,\n            body: {\n              email,\n              password,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else if ('phone' in credentials) {\n          const {\n            phone,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n            headers: this.headers,\n            body: {\n              phone,\n              password,\n              data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else {\n          throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n        }\n        const {\n          data,\n          error\n        } = res;\n        if (error || !data) return {\n          data: {\n            user: null,\n            session: null\n          },\n          error\n        };\n        if (data.session) {\n          yield this._saveSession(data.session);\n          this._notifyAllSubscribers('SIGNED_IN', data.session);\n        }\n        return {\n          data,\n          error\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Log in an existing user via a third-party provider.\n   */\n  signInWithOAuth(credentials) {\n    var _a, _b, _c, _d;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this._removeSession();\n      return this._handleProviderSignIn(credentials.provider, {\n        redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n        scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n        queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n        skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect\n      });\n    });\n  }\n  /**\n   * Log in a user using magiclink or a one-time password (OTP).\n   *\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n   *\n   * Be aware that you may get back an error message that will not distinguish\n   * between the cases where the account does not exist or, that the account\n   * can only be accessed via social login.\n   */\n  signInWithOtp(credentials) {\n    var _a, _b, _c, _d;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        if ('email' in credentials) {\n          const {\n            email,\n            options\n          } = credentials;\n          const {\n            error\n          } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n            headers: this.headers,\n            body: {\n              email,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n          });\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n        if ('phone' in credentials) {\n          const {\n            phone,\n            options\n          } = credentials;\n          const {\n            error\n          } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n            headers: this.headers,\n            body: {\n              phone,\n              data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n              create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            }\n          });\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n        throw new AuthInvalidCredentialsError('You must provide either an email or phone number.');\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   */\n  verifyOtp(params) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        const {\n          data,\n          error\n        } = yield _request(this.fetch, 'POST', `${this.url}/verify`, {\n          headers: this.headers,\n          body: Object.assign(Object.assign({}, params), {\n            gotrue_meta_security: {\n              captcha_token: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken\n            }\n          }),\n          redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n          xform: _sessionResponse\n        });\n        if (error) {\n          throw error;\n        }\n        if (!data) {\n          throw 'An error occurred on token verification.';\n        }\n        const session = data.session;\n        const user = data.user;\n        if (session === null || session === void 0 ? void 0 : session.access_token) {\n          yield this._saveSession(session);\n          this._notifyAllSubscribers('SIGNED_IN', session);\n        }\n        return {\n          data: {\n            user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Attempts a single-sign on using an enterprise Identity Provider. A\n   * successful SSO attempt will redirect the current page to the identity\n   * provider authorization page. The redirect URL is implementation and SSO\n   * protocol specific.\n   *\n   * You can use it by providing a SSO domain. Typically you can extract this\n   * domain by asking users for their email address. If this domain is\n   * registered on the Auth instance the redirect will use that organization's\n   * currently active SSO Identity Provider for the login.\n   *\n   * If you have built an organization-specific login page, you can use the\n   * organization's SSO Identity Provider UUID directly instead.\n   *\n   * This API is experimental and availability is conditional on correct\n   * settings on the Auth service.\n   *\n   * @experimental\n   */\n  signInWithSSO(params) {\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        return yield _request(this.fetch, 'POST', `${this.url}/sso`, {\n          body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, 'providerId' in params ? {\n            provider_id: params.providerId\n          } : null), 'domain' in params ? {\n            domain: params.domain\n          } : null), {\n            redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n          }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n            gotrue_meta_security: {\n              captcha_token: params.options.captchaToken\n            }\n          } : null), {\n            skip_http_redirect: true\n          }),\n          headers: this.headers,\n          xform: _ssoResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Returns the session, refreshing it if necessary.\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n   */\n  getSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // make sure we've read the session from the url if there is one\n      // save to just await, as long we make sure _initialize() never throws\n      yield this.initializePromise;\n      let currentSession = null;\n      if (this.persistSession) {\n        const maybeSession = yield getItemAsync(this.storage, this.storageKey);\n        if (maybeSession !== null) {\n          if (this._isValidSession(maybeSession)) {\n            currentSession = maybeSession;\n          } else {\n            yield this._removeSession();\n          }\n        }\n      } else {\n        currentSession = this.inMemorySession;\n      }\n      if (!currentSession) {\n        return {\n          data: {\n            session: null\n          },\n          error: null\n        };\n      }\n      const hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1000 : false;\n      if (!hasExpired) {\n        return {\n          data: {\n            session: currentSession\n          },\n          error: null\n        };\n      }\n      const {\n        session,\n        error\n      } = yield this._callRefreshToken(currentSession.refresh_token);\n      if (error) {\n        return {\n          data: {\n            session: null\n          },\n          error\n        };\n      }\n      return {\n        data: {\n          session\n        },\n        error: null\n      };\n    });\n  }\n  /**\n   * Gets the current user details if there is an existing session.\n   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n   */\n  getUser(jwt) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!jwt) {\n          const {\n            data,\n            error\n          } = yield this.getSession();\n          if (error) {\n            throw error;\n          }\n          // Default to Authorization header if there is no existing session\n          jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n        }\n        return yield _request(this.fetch, 'GET', `${this.url}/user`, {\n          headers: this.headers,\n          jwt: jwt,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n  updateUser(attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n        if (sessionError) {\n          throw sessionError;\n        }\n        if (!sessionData.session) {\n          throw new AuthSessionMissingError();\n        }\n        const session = sessionData.session;\n        const {\n          data,\n          error: userError\n        } = yield _request(this.fetch, 'PUT', `${this.url}/user`, {\n          headers: this.headers,\n          body: attributes,\n          jwt: session.access_token,\n          xform: _userResponse\n        });\n        if (userError) throw userError;\n        session.user = data.user;\n        yield this._saveSession(session);\n        this._notifyAllSubscribers('USER_UPDATED', session);\n        return {\n          data: {\n            user: session.user\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Decodes a JWT (without performing any validation).\n   */\n  _decodeJWT(jwt) {\n    return decodeJWTPayload(jwt);\n  }\n  /**\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n   * If the refresh token or access token in the current session is invalid, an error will be thrown.\n   * @param currentSession The current session that minimally contains an access token and refresh token.\n   */\n  setSession(currentSession) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!currentSession.access_token || !currentSession.refresh_token) {\n          throw new AuthSessionMissingError();\n        }\n        const timeNow = Date.now() / 1000;\n        let expiresAt = timeNow;\n        let hasExpired = true;\n        let session = null;\n        const payload = decodeJWTPayload(currentSession.access_token);\n        if (payload.exp) {\n          expiresAt = payload.exp;\n          hasExpired = expiresAt <= timeNow;\n        }\n        if (hasExpired) {\n          const {\n            session: refreshedSession,\n            error\n          } = yield this._callRefreshToken(currentSession.refresh_token);\n          if (error) {\n            return {\n              data: {\n                user: null,\n                session: null\n              },\n              error: error\n            };\n          }\n          if (!refreshedSession) {\n            return {\n              data: {\n                user: null,\n                session: null\n              },\n              error: null\n            };\n          }\n          session = refreshedSession;\n        } else {\n          const {\n            data,\n            error\n          } = yield this.getUser(currentSession.access_token);\n          if (error) {\n            throw error;\n          }\n          session = {\n            access_token: currentSession.access_token,\n            refresh_token: currentSession.refresh_token,\n            user: data.user,\n            token_type: 'bearer',\n            expires_in: expiresAt - timeNow,\n            expires_at: expiresAt\n          };\n          yield this._saveSession(session);\n          this._notifyAllSubscribers('SIGNED_IN', session);\n        }\n        return {\n          data: {\n            user: session.user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              user: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Returns a new session, regardless of expiry status.\n   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n   * If the current session's refresh token is invalid, an error will be thrown.\n   * @param currentSession The current session. If passed in, it must contain a refresh token.\n   */\n  refreshSession(currentSession) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!currentSession) {\n          const {\n            data,\n            error\n          } = yield this.getSession();\n          if (error) {\n            throw error;\n          }\n          currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n        }\n        if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n          throw new AuthSessionMissingError();\n        }\n        const {\n          session,\n          error\n        } = yield this._callRefreshToken(currentSession.refresh_token);\n        if (error) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: error\n          };\n        }\n        if (!session) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: null\n          };\n        }\n        return {\n          data: {\n            user: session.user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Gets the session data from a URL string\n   */\n  _getSessionFromUrl() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.');\n        if (!this._isImplicitGrantFlow()) {\n          throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n        }\n        const error_description = getParameterByName('error_description');\n        if (error_description) {\n          const error_code = getParameterByName('error_code');\n          if (!error_code) throw new AuthImplicitGrantRedirectError('No error_code detected.');\n          const error = getParameterByName('error');\n          if (!error) throw new AuthImplicitGrantRedirectError('No error detected.');\n          throw new AuthImplicitGrantRedirectError(error_description, {\n            error,\n            code: error_code\n          });\n        }\n        const provider_token = getParameterByName('provider_token');\n        const provider_refresh_token = getParameterByName('provider_refresh_token');\n        const access_token = getParameterByName('access_token');\n        if (!access_token) throw new AuthImplicitGrantRedirectError('No access_token detected.');\n        const expires_in = getParameterByName('expires_in');\n        if (!expires_in) throw new AuthImplicitGrantRedirectError('No expires_in detected.');\n        const refresh_token = getParameterByName('refresh_token');\n        if (!refresh_token) throw new AuthImplicitGrantRedirectError('No refresh_token detected.');\n        const token_type = getParameterByName('token_type');\n        if (!token_type) throw new AuthImplicitGrantRedirectError('No token_type detected.');\n        const timeNow = Math.round(Date.now() / 1000);\n        const expires_at = timeNow + parseInt(expires_in);\n        const {\n          data,\n          error\n        } = yield this.getUser(access_token);\n        if (error) throw error;\n        const user = data.user;\n        const session = {\n          provider_token,\n          provider_refresh_token,\n          access_token,\n          expires_in: parseInt(expires_in),\n          expires_at,\n          refresh_token,\n          token_type,\n          user\n        };\n        const redirectType = getParameterByName('type');\n        // Remove tokens from URL\n        window.location.hash = '';\n        return {\n          data: {\n            session,\n            redirectType\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              redirectType: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n   */\n  _isImplicitGrantFlow() {\n    return isBrowser() && (Boolean(getParameterByName('access_token')) || Boolean(getParameterByName('error_description')));\n  }\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n   */\n  signOut() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data,\n        error: sessionError\n      } = yield this.getSession();\n      if (sessionError) {\n        return {\n          error: sessionError\n        };\n      }\n      const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n      if (accessToken) {\n        const {\n          error\n        } = yield this.admin.signOut(accessToken);\n        if (error) {\n          // ignore 404s since user might not exist anymore\n          // ignore 401s since an invalid or expired JWT should sign out the current session\n          if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\n            return {\n              error\n            };\n          }\n        }\n      }\n      yield this._removeSession();\n      this._notifyAllSubscribers('SIGNED_OUT', null);\n      return {\n        error: null\n      };\n    });\n  }\n  /**\n   * Receive a notification every time an auth event happens.\n   * @param callback A callback function to be invoked when an auth event happens.\n   */\n  onAuthStateChange(callback) {\n    const id = uuid();\n    const subscription = {\n      id,\n      callback,\n      unsubscribe: () => {\n        this.stateChangeEmitters.delete(id);\n      }\n    };\n    this.stateChangeEmitters.set(id, subscription);\n    return {\n      data: {\n        subscription\n      }\n    };\n  }\n  /**\n   * Sends a password reset request to an email address.\n   * @param email The email address of the user.\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n   */\n  resetPasswordForEmail(email, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, 'POST', `${this.url}/recover`, {\n          body: {\n            email,\n            gotrue_meta_security: {\n              captcha_token: options.captchaToken\n            }\n          },\n          headers: this.headers,\n          redirectTo: options.redirectTo\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  _refreshAccessToken(refreshToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const startedAt = Date.now();\n        // will attempt to refresh the token with exponential backoff\n        return yield retryable(attempt => __awaiter(this, void 0, void 0, function* () {\n          yield sleep(attempt * 200); // 0, 200, 400, 800, ...\n          return yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n            body: {\n              refresh_token: refreshToken\n            },\n            headers: this.headers,\n            xform: _sessionResponse\n          });\n        }), (attempt, _, result) => result && result.error && result.error instanceof AuthRetryableFetchError &&\n        // retryable only if the request can be sent before the backoff overflows the tick duration\n        Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION);\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              user: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  _isValidSession(maybeSession) {\n    const isValidSession = typeof maybeSession === 'object' && maybeSession !== null && 'access_token' in maybeSession && 'refresh_token' in maybeSession && 'expires_at' in maybeSession;\n    return isValidSession;\n  }\n  _handleProviderSignIn(provider, options = {}) {\n    const url = this._getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams\n    });\n    // try to open on the browser\n    if (isBrowser() && !options.skipBrowserRedirect) {\n      window.location.assign(url);\n    }\n    return {\n      data: {\n        provider,\n        url\n      },\n      error: null\n    };\n  }\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n  _recoverAndRefresh() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const currentSession = yield getItemAsync(this.storage, this.storageKey);\n        if (!this._isValidSession(currentSession)) {\n          if (currentSession !== null) {\n            yield this._removeSession();\n          }\n          return;\n        }\n        const timeNow = Math.round(Date.now() / 1000);\n        if (((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN) {\n          if (this.autoRefreshToken && currentSession.refresh_token) {\n            const {\n              error\n            } = yield this._callRefreshToken(currentSession.refresh_token);\n            if (error) {\n              console.log(error.message);\n              yield this._removeSession();\n            }\n          } else {\n            yield this._removeSession();\n          }\n        } else {\n          if (this.persistSession) {\n            yield this._saveSession(currentSession);\n          }\n          this._notifyAllSubscribers('SIGNED_IN', currentSession);\n        }\n      } catch (err) {\n        console.error(err);\n        return;\n      }\n    });\n  }\n  _callRefreshToken(refreshToken) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      // refreshing is already in progress\n      if (this.refreshingDeferred) {\n        return this.refreshingDeferred.promise;\n      }\n      try {\n        this.refreshingDeferred = new Deferred();\n        if (!refreshToken) {\n          throw new AuthSessionMissingError();\n        }\n        const {\n          data,\n          error\n        } = yield this._refreshAccessToken(refreshToken);\n        if (error) throw error;\n        if (!data.session) throw new AuthSessionMissingError();\n        yield this._saveSession(data.session);\n        this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n        const result = {\n          session: data.session,\n          error: null\n        };\n        this.refreshingDeferred.resolve(result);\n        return result;\n      } catch (error) {\n        if (isAuthError(error)) {\n          const result = {\n            session: null,\n            error\n          };\n          (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n          return result;\n        }\n        (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n        throw error;\n      } finally {\n        this.refreshingDeferred = null;\n      }\n    });\n  }\n  _notifyAllSubscribers(event, session, broadcast = true) {\n    if (this.broadcastChannel && broadcast) {\n      this.broadcastChannel.postMessage({\n        event,\n        session\n      });\n    }\n    this.stateChangeEmitters.forEach(x => x.callback(event, session));\n  }\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n  _saveSession(session) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.persistSession) {\n        this.inMemorySession = session;\n      }\n      if (this.persistSession && session.expires_at) {\n        yield this._persistSession(session);\n      }\n    });\n  }\n  _persistSession(currentSession) {\n    return setItemAsync(this.storage, this.storageKey, currentSession);\n  }\n  _removeSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.persistSession) {\n        yield removeItemAsync(this.storage, this.storageKey);\n      } else {\n        this.inMemorySession = null;\n      }\n    });\n  }\n  /**\n   * Removes any registered visibilitychange callback.\n   *\n   * {@see #startAutoRefresh}\n   * {@see #stopAutoRefresh}\n   */\n  _removeVisibilityChangedCallback() {\n    const callback = this.visibilityChangedCallback;\n    this.visibilityChangedCallback = null;\n    try {\n      if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n        window.removeEventListener('visibilitychange', callback);\n      }\n    } catch (e) {\n      console.error('removing visibilitychange callback failed', e);\n    }\n  }\n  /**\n   * This is the private implementation of {@link #startAutoRefresh}. Use this\n   * within the library.\n   */\n  _startAutoRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this._stopAutoRefresh();\n      const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION);\n      this.autoRefreshTicker = ticker;\n      if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\n        // ticker is a NodeJS Timeout object that has an `unref` method\n        // https://nodejs.org/api/timers.html#timeoutunref\n        // When auto refresh is used in NodeJS (like for testing) the\n        // `setInterval` is preventing the process from being marked as\n        // finished and tests run endlessly. This can be prevented by calling\n        // `unref()` on the returned object.\n        ticker.unref();\n      }\n      // run the tick immediately\n      yield this._autoRefreshTokenTick();\n    });\n  }\n  /**\n   * This is the private implementation of {@link #stopAutoRefresh}. Use this\n   * within the library.\n   */\n  _stopAutoRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const ticker = this.autoRefreshTicker;\n      this.autoRefreshTicker = null;\n      if (ticker) {\n        clearInterval(ticker);\n      }\n    });\n  }\n  /**\n   * Starts an auto-refresh process in the background. The session is checked\n   * every few seconds. Close to the time of expiration a process is started to\n   * refresh the session. If refreshing fails it will be retried for as long as\n   * necessary.\n   *\n   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n   * to call this function, it will be called for you.\n   *\n   * On browsers the refresh process works only when the tab/window is in the\n   * foreground to conserve resources as well as prevent race conditions and\n   * flooding auth with requests. If you call this method any managed\n   * visibility change callback will be removed and you must manage visibility\n   * changes on your own.\n   *\n   * On non-browser platforms the refresh process works *continuously* in the\n   * background, which may not be desireable. You should hook into your\n   * platform's foreground indication mechanism and call these methods\n   * appropriately to conserve resources.\n   *\n   * {@see #stopAutoRefresh}\n   */\n  startAutoRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._removeVisibilityChangedCallback();\n      yield this._startAutoRefresh();\n    });\n  }\n  /**\n   * Stops an active auto refresh process running in the background (if any).\n   *\n   * If you call this method any managed visibility change callback will be\n   * removed and you must manage visibility changes on your own.\n   *\n   * See {@link #startAutoRefresh} for more details.\n   */\n  stopAutoRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._removeVisibilityChangedCallback();\n      yield this._stopAutoRefresh();\n    });\n  }\n  /**\n   * Runs the auto refresh token tick.\n   */\n  _autoRefreshTokenTick() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const now = Date.now();\n      try {\n        const {\n          data: {\n            session\n          },\n          error\n        } = yield this.getSession();\n        if (!session || !session.refresh_token || !session.expires_at) {\n          return;\n        }\n        // session will expire in this many ticks (or has already expired if <= 0)\n        const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION);\n        if (expiresInTicks < AUTO_REFRESH_TICK_THRESHOLD) {\n          yield this._callRefreshToken(session.refresh_token);\n        }\n      } catch (e) {\n        console.error('Auto refresh tick failed with error. This is likely a transient error.', e);\n      }\n    });\n  }\n  /**\n   * Registers callbacks on the browser / platform, which in-turn run\n   * algorithms when the browser window/tab are in foreground. On non-browser\n   * platforms it assumes always foreground.\n   */\n  _handleVisibilityChange() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n        if (this.autoRefreshToken) {\n          // in non-browser environments the refresh token ticker runs always\n          this.startAutoRefresh();\n        }\n        return false;\n      }\n      try {\n        this.visibilityChangedCallback = () => __awaiter(this, void 0, void 0, function* () {\n          return yield this._onVisibilityChanged(false);\n        });\n        window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', this.visibilityChangedCallback);\n        // now immediately call the visbility changed callback to setup with the\n        // current visbility state\n        yield this._onVisibilityChanged(true); // initial call\n      } catch (error) {\n        console.error('_handleVisibilityChange', error);\n      }\n    });\n  }\n  /**\n   * Callback registered with `window.addEventListener('visibilitychange')`.\n   */\n  _onVisibilityChanged(isInitial) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (document.visibilityState === 'visible') {\n        if (!isInitial) {\n          // initial visibility change setup is handled in another flow under #initialize()\n          yield this.initializePromise;\n          yield this._recoverAndRefresh();\n        }\n        if (this.autoRefreshToken) {\n          // in browser environments the refresh token ticker runs only on focused tabs\n          // which prevents race conditions\n          this._startAutoRefresh();\n        }\n      } else if (document.visibilityState === 'hidden') {\n        if (this.autoRefreshToken) {\n          this._stopAutoRefresh();\n        }\n      }\n    });\n  }\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n   */\n  _getUrlForProvider(provider, options) {\n    const urlParams = [`provider=${encodeURIComponent(provider)}`];\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n    }\n    if (options === null || options === void 0 ? void 0 : options.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n    }\n    if (options === null || options === void 0 ? void 0 : options.queryParams) {\n      const query = new URLSearchParams(options.queryParams);\n      urlParams.push(query.toString());\n    }\n    return `${this.url}/authorize?${urlParams.join('&')}`;\n  }\n  _unenroll(params) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n        return yield _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * {@see GoTrueMFAApi#enroll}\n   */\n  _enroll(params) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n        const {\n          data,\n          error\n        } = yield _request(this.fetch, 'POST', `${this.url}/factors`, {\n          body: {\n            friendly_name: params.friendlyName,\n            factor_type: params.factorType,\n            issuer: params.issuer\n          },\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n        if (error) {\n          return {\n            data: null,\n            error\n          };\n        }\n        if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {\n          data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n        }\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * {@see GoTrueMFAApi#verify}\n   */\n  _verify(params) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n        const {\n          data,\n          error\n        } = yield _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/verify`, {\n          body: {\n            code: params.code,\n            challenge_id: params.challengeId\n          },\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n        if (error) {\n          return {\n            data: null,\n            error\n          };\n        }\n        yield this._saveSession(Object.assign({\n          expires_at: Math.round(Date.now() / 1000) + data.expires_in\n        }, data));\n        this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);\n        return {\n          data,\n          error\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * {@see GoTrueMFAApi#challenge}\n   */\n  _challenge(params) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n        return yield _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/challenge`, {\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * {@see GoTrueMFAApi#challengeAndVerify}\n   */\n  _challengeAndVerify(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data: challengeData,\n        error: challengeError\n      } = yield this._challenge({\n        factorId: params.factorId\n      });\n      if (challengeError) {\n        return {\n          data: null,\n          error: challengeError\n        };\n      }\n      return yield this._verify({\n        factorId: params.factorId,\n        challengeId: challengeData.id,\n        code: params.code\n      });\n    });\n  }\n  /**\n   * {@see GoTrueMFAApi#listFactors}\n   */\n  _listFactors() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data: {\n          user\n        },\n        error: userError\n      } = yield this.getUser();\n      if (userError) {\n        return {\n          data: null,\n          error: userError\n        };\n      }\n      const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n      const totp = factors.filter(factor => factor.factor_type === 'totp' && factor.status === 'verified');\n      return {\n        data: {\n          all: factors,\n          totp\n        },\n        error: null\n      };\n    });\n  }\n  /**\n   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n   */\n  _getAuthenticatorAssuranceLevel() {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data: {\n          session\n        },\n        error: sessionError\n      } = yield this.getSession();\n      if (sessionError) {\n        return {\n          data: null,\n          error: sessionError\n        };\n      }\n      if (!session) {\n        return {\n          data: {\n            currentLevel: null,\n            nextLevel: null,\n            currentAuthenticationMethods: []\n          },\n          error: null\n        };\n      }\n      const payload = this._decodeJWT(session.access_token);\n      let currentLevel = null;\n      if (payload.aal) {\n        currentLevel = payload.aal;\n      }\n      let nextLevel = currentLevel;\n      const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter(factor => factor.status === 'verified')) !== null && _b !== void 0 ? _b : [];\n      if (verifiedFactors.length > 0) {\n        nextLevel = 'aal2';\n      }\n      const currentAuthenticationMethods = payload.amr || [];\n      return {\n        data: {\n          currentLevel,\n          nextLevel,\n          currentAuthenticationMethods\n        },\n        error: null\n      };\n    });\n  }\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","GoTrueAdminApi","DEFAULT_HEADERS","EXPIRY_MARGIN","GOTRUE_URL","STORAGE_KEY","AuthImplicitGrantRedirectError","AuthInvalidCredentialsError","AuthRetryableFetchError","AuthSessionMissingError","AuthUnknownError","isAuthApiError","isAuthError","_request","_sessionResponse","_userResponse","_ssoResponse","decodeJWTPayload","Deferred","getItemAsync","getParameterByName","isBrowser","removeItemAsync","resolveFetch","setItemAsync","uuid","retryable","sleep","localStorageAdapter","polyfillGlobalThis","DEFAULT_OPTIONS","url","storageKey","autoRefreshToken","persistSession","detectSessionInUrl","headers","AUTO_REFRESH_TICK_DURATION","AUTO_REFRESH_TICK_THRESHOLD","GoTrueClient","constructor","options","stateChangeEmitters","Map","autoRefreshTicker","visibilityChangedCallback","refreshingDeferred","initializePromise","broadcastChannel","settings","Object","assign","inMemorySession","storage","admin","fetch","mfa","verify","_verify","bind","enroll","_enroll","unenroll","_unenroll","challenge","_challenge","listFactors","_listFactors","challengeAndVerify","_challengeAndVerify","getAuthenticatorAssuranceLevel","_getAuthenticatorAssuranceLevel","globalThis","BroadcastChannel","addEventListener","event","_notifyAllSubscribers","data","session","initialize","_initialize","_isImplicitGrantFlow","error","_getSessionFromUrl","_removeSession","redirectType","_saveSession","_recoverAndRefresh","_handleVisibilityChange","signUp","credentials","_a","_b","res","email","password","redirectTo","emailRedirectTo","body","gotrue_meta_security","captcha_token","captchaToken","xform","phone","user","signInWithPassword","signInWithOAuth","_c","_d","_handleProviderSignIn","provider","scopes","queryParams","skipBrowserRedirect","signInWithOtp","create_user","shouldCreateUser","verifyOtp","params","access_token","signInWithSSO","provider_id","providerId","domain","redirect_to","undefined","skip_http_redirect","getSession","currentSession","maybeSession","_isValidSession","hasExpired","expires_at","Date","now","_callRefreshToken","refresh_token","getUser","jwt","updateUser","attributes","sessionData","sessionError","userError","_decodeJWT","setSession","timeNow","expiresAt","payload","exp","refreshedSession","token_type","expires_in","refreshSession","error_description","error_code","code","provider_token","provider_refresh_token","Math","round","parseInt","window","location","hash","Boolean","signOut","accessToken","status","onAuthStateChange","callback","id","subscription","unsubscribe","delete","set","resetPasswordForEmail","_refreshAccessToken","refreshToken","startedAt","attempt","_","isValidSession","_getUrlForProvider","Infinity","console","log","message","err","promise","broadcast","postMessage","forEach","x","_persistSession","_removeVisibilityChangedCallback","removeEventListener","_startAutoRefresh","_stopAutoRefresh","ticker","setInterval","_autoRefreshTokenTick","unref","clearInterval","startAutoRefresh","stopAutoRefresh","expiresInTicks","floor","_onVisibilityChanged","isInitial","document","visibilityState","urlParams","encodeURIComponent","push","query","URLSearchParams","toString","join","factorId","friendly_name","friendlyName","factor_type","factorType","issuer","totp","qr_code","challenge_id","challengeId","challengeData","challengeError","factors","filter","factor","all","currentLevel","nextLevel","currentAuthenticationMethods","aal","verifiedFactors","length","amr"],"sources":["E:/Web projects/sistema-de-puntaje-prejuveniles/node_modules/@supabase/gotrue-js/dist/module/GoTrueClient.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport GoTrueAdminApi from './GoTrueAdminApi';\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, STORAGE_KEY, } from './lib/constants';\nimport { AuthImplicitGrantRedirectError, AuthInvalidCredentialsError, AuthRetryableFetchError, AuthSessionMissingError, AuthUnknownError, isAuthApiError, isAuthError, } from './lib/errors';\nimport { _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch';\nimport { decodeJWTPayload, Deferred, getItemAsync, getParameterByName, isBrowser, removeItemAsync, resolveFetch, setItemAsync, uuid, retryable, sleep, } from './lib/helpers';\nimport localStorageAdapter from './lib/local-storage';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: GOTRUE_URL,\n    storageKey: STORAGE_KEY,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    headers: DEFAULT_HEADERS,\n};\n/** Current session will be checked for refresh at this interval. */\nconst AUTO_REFRESH_TICK_DURATION = 10 * 1000;\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */\nconst AUTO_REFRESH_TICK_THRESHOLD = 3;\nexport default class GoTrueClient {\n    /**\n     * Create a new client for use in the browser.\n     */\n    constructor(options) {\n        this.stateChangeEmitters = new Map();\n        this.autoRefreshTicker = null;\n        this.visibilityChangedCallback = null;\n        this.refreshingDeferred = null;\n        /**\n         * Keeps track of the async client initialization.\n         * When null or not yet resolved the auth state is `unknown`\n         * Once resolved the the auth state is known and it's save to call any further client methods.\n         * Keep extra care to never reject or throw uncaught errors\n         */\n        this.initializePromise = null;\n        this.detectSessionInUrl = true;\n        /**\n         * Used to broadcast state change events to other tabs listening.\n         */\n        this.broadcastChannel = null;\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.inMemorySession = null;\n        this.storageKey = settings.storageKey;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.persistSession = settings.persistSession;\n        this.storage = settings.storage || localStorageAdapter;\n        this.admin = new GoTrueAdminApi({\n            url: settings.url,\n            headers: settings.headers,\n            fetch: settings.fetch,\n        });\n        this.url = settings.url;\n        this.headers = settings.headers;\n        this.fetch = resolveFetch(settings.fetch);\n        this.detectSessionInUrl = settings.detectSessionInUrl;\n        this.mfa = {\n            verify: this._verify.bind(this),\n            enroll: this._enroll.bind(this),\n            unenroll: this._unenroll.bind(this),\n            challenge: this._challenge.bind(this),\n            listFactors: this._listFactors.bind(this),\n            challengeAndVerify: this._challengeAndVerify.bind(this),\n            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n        };\n        if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n            this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n            this.broadcastChannel.addEventListener('message', (event) => {\n                this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages\n            });\n        }\n        this.initialize();\n    }\n    /**\n     * Initializes the client session either from the url or from storage.\n     * This method is automatically called when instantiating the client, but should also be called\n     * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n     */\n    initialize() {\n        if (!this.initializePromise) {\n            this.initializePromise = this._initialize();\n        }\n        return this.initializePromise;\n    }\n    /**\n     * IMPORTANT:\n     * 1. Never throw in this method, as it is called from the constructor\n     * 2. Never return a session from this method as it would be cached over\n     *    the whole lifetime of the client\n     */\n    _initialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.initializePromise) {\n                return this.initializePromise;\n            }\n            try {\n                if (this.detectSessionInUrl && this._isImplicitGrantFlow()) {\n                    const { data, error } = yield this._getSessionFromUrl();\n                    if (error) {\n                        // failed login attempt via url,\n                        // remove old session as in verifyOtp, signUp and signInWith*\n                        yield this._removeSession();\n                        return { error };\n                    }\n                    const { session, redirectType } = data;\n                    yield this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN', session);\n                    if (redirectType === 'recovery') {\n                        this._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n                    }\n                    return { error: null };\n                }\n                // no login attempt via callback url try to recover session from storage\n                yield this._recoverAndRefresh();\n                return { error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { error };\n                }\n                return {\n                    error: new AuthUnknownError('Unexpected error during initialization', error),\n                };\n            }\n            finally {\n                yield this._handleVisibilityChange();\n            }\n        });\n    }\n    /**\n     * Creates a new user.\n     *\n     * Be aware that if a user account exists in the system you may get back an\n     * error message that attempts to hide this information from the user.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */\n    signUp(credentials) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this._removeSession();\n                let res;\n                if ('email' in credentials) {\n                    const { email, password, options } = credentials;\n                    res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n                        headers: this.headers,\n                        redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                        body: {\n                            email,\n                            password,\n                            data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        },\n                        xform: _sessionResponse,\n                    });\n                }\n                else if ('phone' in credentials) {\n                    const { phone, password, options } = credentials;\n                    res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n                        headers: this.headers,\n                        body: {\n                            phone,\n                            password,\n                            data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        },\n                        xform: _sessionResponse,\n                    });\n                }\n                else {\n                    throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n                }\n                const { data, error } = res;\n                if (error || !data) {\n                    return { data: { user: null, session: null }, error: error };\n                }\n                const session = data.session;\n                const user = data.user;\n                if (data.session) {\n                    yield this._saveSession(data.session);\n                    this._notifyAllSubscribers('SIGNED_IN', session);\n                }\n                return { data: { user, session }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null, session: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Log in an existing user with an email and password or phone and password.\n     *\n     * Be aware that you may get back an error message that will not distingish\n     * between the cases where the account does not exist or that the\n     * email/phone and password combination is wrong or that the account can only\n     * be accessed via social login.\n     */\n    signInWithPassword(credentials) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this._removeSession();\n                let res;\n                if ('email' in credentials) {\n                    const { email, password, options } = credentials;\n                    res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n                        headers: this.headers,\n                        body: {\n                            email,\n                            password,\n                            data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        },\n                        xform: _sessionResponse,\n                    });\n                }\n                else if ('phone' in credentials) {\n                    const { phone, password, options } = credentials;\n                    res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n                        headers: this.headers,\n                        body: {\n                            phone,\n                            password,\n                            data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        },\n                        xform: _sessionResponse,\n                    });\n                }\n                else {\n                    throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n                }\n                const { data, error } = res;\n                if (error || !data)\n                    return { data: { user: null, session: null }, error };\n                if (data.session) {\n                    yield this._saveSession(data.session);\n                    this._notifyAllSubscribers('SIGNED_IN', data.session);\n                }\n                return { data, error };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null, session: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     */\n    signInWithOAuth(credentials) {\n        var _a, _b, _c, _d;\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._removeSession();\n            return this._handleProviderSignIn(credentials.provider, {\n                redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n                skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect,\n            });\n        });\n    }\n    /**\n     * Log in a user using magiclink or a one-time password (OTP).\n     *\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or, that the account\n     * can only be accessed via social login.\n     */\n    signInWithOtp(credentials) {\n        var _a, _b, _c, _d;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this._removeSession();\n                if ('email' in credentials) {\n                    const { email, options } = credentials;\n                    const { error } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n                        headers: this.headers,\n                        body: {\n                            email,\n                            data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                            create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        },\n                        redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    });\n                    return { data: { user: null, session: null }, error };\n                }\n                if ('phone' in credentials) {\n                    const { phone, options } = credentials;\n                    const { error } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n                        headers: this.headers,\n                        body: {\n                            phone,\n                            data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n                            create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        },\n                    });\n                    return { data: { user: null, session: null }, error };\n                }\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number.');\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null, session: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     */\n    verifyOtp(params) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this._removeSession();\n                const { data, error } = yield _request(this.fetch, 'POST', `${this.url}/verify`, {\n                    headers: this.headers,\n                    body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken } }),\n                    redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n                    xform: _sessionResponse,\n                });\n                if (error) {\n                    throw error;\n                }\n                if (!data) {\n                    throw 'An error occurred on token verification.';\n                }\n                const session = data.session;\n                const user = data.user;\n                if (session === null || session === void 0 ? void 0 : session.access_token) {\n                    yield this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN', session);\n                }\n                return { data: { user, session }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null, session: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Attempts a single-sign on using an enterprise Identity Provider. A\n     * successful SSO attempt will redirect the current page to the identity\n     * provider authorization page. The redirect URL is implementation and SSO\n     * protocol specific.\n     *\n     * You can use it by providing a SSO domain. Typically you can extract this\n     * domain by asking users for their email address. If this domain is\n     * registered on the Auth instance the redirect will use that organization's\n     * currently active SSO Identity Provider for the login.\n     *\n     * If you have built an organization-specific login page, you can use the\n     * organization's SSO Identity Provider UUID directly instead.\n     *\n     * This API is experimental and availability is conditional on correct\n     * settings on the Auth service.\n     *\n     * @experimental\n     */\n    signInWithSSO(params) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this._removeSession();\n                return yield _request(this.fetch, 'POST', `${this.url}/sso`, {\n                    body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, ('providerId' in params ? { provider_id: params.providerId } : null)), ('domain' in params ? { domain: params.domain } : null)), { redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined }), (((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken)\n                        ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } }\n                        : null)), { skip_http_redirect: true }),\n                    headers: this.headers,\n                    xform: _ssoResponse,\n                });\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Returns the session, refreshing it if necessary.\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n     */\n    getSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // make sure we've read the session from the url if there is one\n            // save to just await, as long we make sure _initialize() never throws\n            yield this.initializePromise;\n            let currentSession = null;\n            if (this.persistSession) {\n                const maybeSession = yield getItemAsync(this.storage, this.storageKey);\n                if (maybeSession !== null) {\n                    if (this._isValidSession(maybeSession)) {\n                        currentSession = maybeSession;\n                    }\n                    else {\n                        yield this._removeSession();\n                    }\n                }\n            }\n            else {\n                currentSession = this.inMemorySession;\n            }\n            if (!currentSession) {\n                return { data: { session: null }, error: null };\n            }\n            const hasExpired = currentSession.expires_at\n                ? currentSession.expires_at <= Date.now() / 1000\n                : false;\n            if (!hasExpired) {\n                return { data: { session: currentSession }, error: null };\n            }\n            const { session, error } = yield this._callRefreshToken(currentSession.refresh_token);\n            if (error) {\n                return { data: { session: null }, error };\n            }\n            return { data: { session }, error: null };\n        });\n    }\n    /**\n     * Gets the current user details if there is an existing session.\n     * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n     */\n    getUser(jwt) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!jwt) {\n                    const { data, error } = yield this.getSession();\n                    if (error) {\n                        throw error;\n                    }\n                    // Default to Authorization header if there is no existing session\n                    jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n                }\n                return yield _request(this.fetch, 'GET', `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: jwt,\n                    xform: _userResponse,\n                });\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Updates user data, if there is a logged in user.\n     */\n    updateUser(attributes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data: sessionData, error: sessionError } = yield this.getSession();\n                if (sessionError) {\n                    throw sessionError;\n                }\n                if (!sessionData.session) {\n                    throw new AuthSessionMissingError();\n                }\n                const session = sessionData.session;\n                const { data, error: userError } = yield _request(this.fetch, 'PUT', `${this.url}/user`, {\n                    headers: this.headers,\n                    body: attributes,\n                    jwt: session.access_token,\n                    xform: _userResponse,\n                });\n                if (userError)\n                    throw userError;\n                session.user = data.user;\n                yield this._saveSession(session);\n                this._notifyAllSubscribers('USER_UPDATED', session);\n                return { data: { user: session.user }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Decodes a JWT (without performing any validation).\n     */\n    _decodeJWT(jwt) {\n        return decodeJWTPayload(jwt);\n    }\n    /**\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\n     * @param currentSession The current session that minimally contains an access token and refresh token.\n     */\n    setSession(currentSession) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!currentSession.access_token || !currentSession.refresh_token) {\n                    throw new AuthSessionMissingError();\n                }\n                const timeNow = Date.now() / 1000;\n                let expiresAt = timeNow;\n                let hasExpired = true;\n                let session = null;\n                const payload = decodeJWTPayload(currentSession.access_token);\n                if (payload.exp) {\n                    expiresAt = payload.exp;\n                    hasExpired = expiresAt <= timeNow;\n                }\n                if (hasExpired) {\n                    const { session: refreshedSession, error } = yield this._callRefreshToken(currentSession.refresh_token);\n                    if (error) {\n                        return { data: { user: null, session: null }, error: error };\n                    }\n                    if (!refreshedSession) {\n                        return { data: { user: null, session: null }, error: null };\n                    }\n                    session = refreshedSession;\n                }\n                else {\n                    const { data, error } = yield this.getUser(currentSession.access_token);\n                    if (error) {\n                        throw error;\n                    }\n                    session = {\n                        access_token: currentSession.access_token,\n                        refresh_token: currentSession.refresh_token,\n                        user: data.user,\n                        token_type: 'bearer',\n                        expires_in: expiresAt - timeNow,\n                        expires_at: expiresAt,\n                    };\n                    yield this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN', session);\n                }\n                return { data: { user: session.user, session }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { session: null, user: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Returns a new session, regardless of expiry status.\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n     * If the current session's refresh token is invalid, an error will be thrown.\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\n     */\n    refreshSession(currentSession) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!currentSession) {\n                    const { data, error } = yield this.getSession();\n                    if (error) {\n                        throw error;\n                    }\n                    currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n                }\n                if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n                    throw new AuthSessionMissingError();\n                }\n                const { session, error } = yield this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return { data: { user: null, session: null }, error: error };\n                }\n                if (!session) {\n                    return { data: { user: null, session: null }, error: null };\n                }\n                return { data: { user: session.user, session }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null, session: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Gets the session data from a URL string\n     */\n    _getSessionFromUrl() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!isBrowser())\n                    throw new AuthImplicitGrantRedirectError('No browser detected.');\n                if (!this._isImplicitGrantFlow()) {\n                    throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n                }\n                const error_description = getParameterByName('error_description');\n                if (error_description) {\n                    const error_code = getParameterByName('error_code');\n                    if (!error_code)\n                        throw new AuthImplicitGrantRedirectError('No error_code detected.');\n                    const error = getParameterByName('error');\n                    if (!error)\n                        throw new AuthImplicitGrantRedirectError('No error detected.');\n                    throw new AuthImplicitGrantRedirectError(error_description, { error, code: error_code });\n                }\n                const provider_token = getParameterByName('provider_token');\n                const provider_refresh_token = getParameterByName('provider_refresh_token');\n                const access_token = getParameterByName('access_token');\n                if (!access_token)\n                    throw new AuthImplicitGrantRedirectError('No access_token detected.');\n                const expires_in = getParameterByName('expires_in');\n                if (!expires_in)\n                    throw new AuthImplicitGrantRedirectError('No expires_in detected.');\n                const refresh_token = getParameterByName('refresh_token');\n                if (!refresh_token)\n                    throw new AuthImplicitGrantRedirectError('No refresh_token detected.');\n                const token_type = getParameterByName('token_type');\n                if (!token_type)\n                    throw new AuthImplicitGrantRedirectError('No token_type detected.');\n                const timeNow = Math.round(Date.now() / 1000);\n                const expires_at = timeNow + parseInt(expires_in);\n                const { data, error } = yield this.getUser(access_token);\n                if (error)\n                    throw error;\n                const user = data.user;\n                const session = {\n                    provider_token,\n                    provider_refresh_token,\n                    access_token,\n                    expires_in: parseInt(expires_in),\n                    expires_at,\n                    refresh_token,\n                    token_type,\n                    user,\n                };\n                const redirectType = getParameterByName('type');\n                // Remove tokens from URL\n                window.location.hash = '';\n                return { data: { session, redirectType }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { session: null, redirectType: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n     */\n    _isImplicitGrantFlow() {\n        return (isBrowser() &&\n            (Boolean(getParameterByName('access_token')) ||\n                Boolean(getParameterByName('error_description'))));\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n     */\n    signOut() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const { data, error: sessionError } = yield this.getSession();\n            if (sessionError) {\n                return { error: sessionError };\n            }\n            const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n            if (accessToken) {\n                const { error } = yield this.admin.signOut(accessToken);\n                if (error) {\n                    // ignore 404s since user might not exist anymore\n                    // ignore 401s since an invalid or expired JWT should sign out the current session\n                    if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\n                        return { error };\n                    }\n                }\n            }\n            yield this._removeSession();\n            this._notifyAllSubscribers('SIGNED_OUT', null);\n            return { error: null };\n        });\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @param callback A callback function to be invoked when an auth event happens.\n     */\n    onAuthStateChange(callback) {\n        const id = uuid();\n        const subscription = {\n            id,\n            callback,\n            unsubscribe: () => {\n                this.stateChangeEmitters.delete(id);\n            },\n        };\n        this.stateChangeEmitters.set(id, subscription);\n        return { data: { subscription } };\n    }\n    /**\n     * Sends a password reset request to an email address.\n     * @param email The email address of the user.\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n     */\n    resetPasswordForEmail(email, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                return yield _request(this.fetch, 'POST', `${this.url}/recover`, {\n                    body: { email, gotrue_meta_security: { captcha_token: options.captchaToken } },\n                    headers: this.headers,\n                    redirectTo: options.redirectTo,\n                });\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */\n    _refreshAccessToken(refreshToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const startedAt = Date.now();\n                // will attempt to refresh the token with exponential backoff\n                return yield retryable((attempt) => __awaiter(this, void 0, void 0, function* () {\n                    yield sleep(attempt * 200); // 0, 200, 400, 800, ...\n                    return yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n                        body: { refresh_token: refreshToken },\n                        headers: this.headers,\n                        xform: _sessionResponse,\n                    });\n                }), (attempt, _, result) => result &&\n                    result.error &&\n                    result.error instanceof AuthRetryableFetchError &&\n                    // retryable only if the request can be sent before the backoff overflows the tick duration\n                    Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION);\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { session: null, user: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    _isValidSession(maybeSession) {\n        const isValidSession = typeof maybeSession === 'object' &&\n            maybeSession !== null &&\n            'access_token' in maybeSession &&\n            'refresh_token' in maybeSession &&\n            'expires_at' in maybeSession;\n        return isValidSession;\n    }\n    _handleProviderSignIn(provider, options = {}) {\n        const url = this._getUrlForProvider(provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n            queryParams: options.queryParams,\n        });\n        // try to open on the browser\n        if (isBrowser() && !options.skipBrowserRedirect) {\n            window.location.assign(url);\n        }\n        return { data: { provider, url }, error: null };\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n    _recoverAndRefresh() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const currentSession = yield getItemAsync(this.storage, this.storageKey);\n                if (!this._isValidSession(currentSession)) {\n                    if (currentSession !== null) {\n                        yield this._removeSession();\n                    }\n                    return;\n                }\n                const timeNow = Math.round(Date.now() / 1000);\n                if (((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN) {\n                    if (this.autoRefreshToken && currentSession.refresh_token) {\n                        const { error } = yield this._callRefreshToken(currentSession.refresh_token);\n                        if (error) {\n                            console.log(error.message);\n                            yield this._removeSession();\n                        }\n                    }\n                    else {\n                        yield this._removeSession();\n                    }\n                }\n                else {\n                    if (this.persistSession) {\n                        yield this._saveSession(currentSession);\n                    }\n                    this._notifyAllSubscribers('SIGNED_IN', currentSession);\n                }\n            }\n            catch (err) {\n                console.error(err);\n                return;\n            }\n        });\n    }\n    _callRefreshToken(refreshToken) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            // refreshing is already in progress\n            if (this.refreshingDeferred) {\n                return this.refreshingDeferred.promise;\n            }\n            try {\n                this.refreshingDeferred = new Deferred();\n                if (!refreshToken) {\n                    throw new AuthSessionMissingError();\n                }\n                const { data, error } = yield this._refreshAccessToken(refreshToken);\n                if (error)\n                    throw error;\n                if (!data.session)\n                    throw new AuthSessionMissingError();\n                yield this._saveSession(data.session);\n                this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n                const result = { session: data.session, error: null };\n                this.refreshingDeferred.resolve(result);\n                return result;\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    const result = { session: null, error };\n                    (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n                    return result;\n                }\n                (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n                throw error;\n            }\n            finally {\n                this.refreshingDeferred = null;\n            }\n        });\n    }\n    _notifyAllSubscribers(event, session, broadcast = true) {\n        if (this.broadcastChannel && broadcast) {\n            this.broadcastChannel.postMessage({ event, session });\n        }\n        this.stateChangeEmitters.forEach((x) => x.callback(event, session));\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n    _saveSession(session) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.persistSession) {\n                this.inMemorySession = session;\n            }\n            if (this.persistSession && session.expires_at) {\n                yield this._persistSession(session);\n            }\n        });\n    }\n    _persistSession(currentSession) {\n        return setItemAsync(this.storage, this.storageKey, currentSession);\n    }\n    _removeSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.persistSession) {\n                yield removeItemAsync(this.storage, this.storageKey);\n            }\n            else {\n                this.inMemorySession = null;\n            }\n        });\n    }\n    /**\n     * Removes any registered visibilitychange callback.\n     *\n     * {@see #startAutoRefresh}\n     * {@see #stopAutoRefresh}\n     */\n    _removeVisibilityChangedCallback() {\n        const callback = this.visibilityChangedCallback;\n        this.visibilityChangedCallback = null;\n        try {\n            if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n                window.removeEventListener('visibilitychange', callback);\n            }\n        }\n        catch (e) {\n            console.error('removing visibilitychange callback failed', e);\n        }\n    }\n    /**\n     * This is the private implementation of {@link #startAutoRefresh}. Use this\n     * within the library.\n     */\n    _startAutoRefresh() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._stopAutoRefresh();\n            const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION);\n            this.autoRefreshTicker = ticker;\n            if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\n                // ticker is a NodeJS Timeout object that has an `unref` method\n                // https://nodejs.org/api/timers.html#timeoutunref\n                // When auto refresh is used in NodeJS (like for testing) the\n                // `setInterval` is preventing the process from being marked as\n                // finished and tests run endlessly. This can be prevented by calling\n                // `unref()` on the returned object.\n                ticker.unref();\n            }\n            // run the tick immediately\n            yield this._autoRefreshTokenTick();\n        });\n    }\n    /**\n     * This is the private implementation of {@link #stopAutoRefresh}. Use this\n     * within the library.\n     */\n    _stopAutoRefresh() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const ticker = this.autoRefreshTicker;\n            this.autoRefreshTicker = null;\n            if (ticker) {\n                clearInterval(ticker);\n            }\n        });\n    }\n    /**\n     * Starts an auto-refresh process in the background. The session is checked\n     * every few seconds. Close to the time of expiration a process is started to\n     * refresh the session. If refreshing fails it will be retried for as long as\n     * necessary.\n     *\n     * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n     * to call this function, it will be called for you.\n     *\n     * On browsers the refresh process works only when the tab/window is in the\n     * foreground to conserve resources as well as prevent race conditions and\n     * flooding auth with requests. If you call this method any managed\n     * visibility change callback will be removed and you must manage visibility\n     * changes on your own.\n     *\n     * On non-browser platforms the refresh process works *continuously* in the\n     * background, which may not be desireable. You should hook into your\n     * platform's foreground indication mechanism and call these methods\n     * appropriately to conserve resources.\n     *\n     * {@see #stopAutoRefresh}\n     */\n    startAutoRefresh() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._removeVisibilityChangedCallback();\n            yield this._startAutoRefresh();\n        });\n    }\n    /**\n     * Stops an active auto refresh process running in the background (if any).\n     *\n     * If you call this method any managed visibility change callback will be\n     * removed and you must manage visibility changes on your own.\n     *\n     * See {@link #startAutoRefresh} for more details.\n     */\n    stopAutoRefresh() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._removeVisibilityChangedCallback();\n            yield this._stopAutoRefresh();\n        });\n    }\n    /**\n     * Runs the auto refresh token tick.\n     */\n    _autoRefreshTokenTick() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const now = Date.now();\n            try {\n                const { data: { session }, error, } = yield this.getSession();\n                if (!session || !session.refresh_token || !session.expires_at) {\n                    return;\n                }\n                // session will expire in this many ticks (or has already expired if <= 0)\n                const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION);\n                if (expiresInTicks < AUTO_REFRESH_TICK_THRESHOLD) {\n                    yield this._callRefreshToken(session.refresh_token);\n                }\n            }\n            catch (e) {\n                console.error('Auto refresh tick failed with error. This is likely a transient error.', e);\n            }\n        });\n    }\n    /**\n     * Registers callbacks on the browser / platform, which in-turn run\n     * algorithms when the browser window/tab are in foreground. On non-browser\n     * platforms it assumes always foreground.\n     */\n    _handleVisibilityChange() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n                if (this.autoRefreshToken) {\n                    // in non-browser environments the refresh token ticker runs always\n                    this.startAutoRefresh();\n                }\n                return false;\n            }\n            try {\n                this.visibilityChangedCallback = () => __awaiter(this, void 0, void 0, function* () { return yield this._onVisibilityChanged(false); });\n                window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', this.visibilityChangedCallback);\n                // now immediately call the visbility changed callback to setup with the\n                // current visbility state\n                yield this._onVisibilityChanged(true); // initial call\n            }\n            catch (error) {\n                console.error('_handleVisibilityChange', error);\n            }\n        });\n    }\n    /**\n     * Callback registered with `window.addEventListener('visibilitychange')`.\n     */\n    _onVisibilityChanged(isInitial) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (document.visibilityState === 'visible') {\n                if (!isInitial) {\n                    // initial visibility change setup is handled in another flow under #initialize()\n                    yield this.initializePromise;\n                    yield this._recoverAndRefresh();\n                }\n                if (this.autoRefreshToken) {\n                    // in browser environments the refresh token ticker runs only on focused tabs\n                    // which prevents race conditions\n                    this._startAutoRefresh();\n                }\n            }\n            else if (document.visibilityState === 'hidden') {\n                if (this.autoRefreshToken) {\n                    this._stopAutoRefresh();\n                }\n            }\n        });\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n     */\n    _getUrlForProvider(provider, options) {\n        const urlParams = [`provider=${encodeURIComponent(provider)}`];\n        if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n            urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n        }\n        if (options === null || options === void 0 ? void 0 : options.scopes) {\n            urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n        }\n        if (options === null || options === void 0 ? void 0 : options.queryParams) {\n            const query = new URLSearchParams(options.queryParams);\n            urlParams.push(query.toString());\n        }\n        return `${this.url}/authorize?${urlParams.join('&')}`;\n    }\n    _unenroll(params) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data: sessionData, error: sessionError } = yield this.getSession();\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                return yield _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                });\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#enroll}\n     */\n    _enroll(params) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data: sessionData, error: sessionError } = yield this.getSession();\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                const { data, error } = yield _request(this.fetch, 'POST', `${this.url}/factors`, {\n                    body: {\n                        friendly_name: params.friendlyName,\n                        factor_type: params.factorType,\n                        issuer: params.issuer,\n                    },\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                });\n                if (error) {\n                    return { data: null, error };\n                }\n                if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {\n                    data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n                }\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#verify}\n     */\n    _verify(params) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data: sessionData, error: sessionError } = yield this.getSession();\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                const { data, error } = yield _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/verify`, {\n                    body: { code: params.code, challenge_id: params.challengeId },\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                });\n                if (error) {\n                    return { data: null, error };\n                }\n                yield this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1000) + data.expires_in }, data));\n                this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);\n                return { data, error };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#challenge}\n     */\n    _challenge(params) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data: sessionData, error: sessionError } = yield this.getSession();\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                return yield _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/challenge`, {\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                });\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#challengeAndVerify}\n     */\n    _challengeAndVerify(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { data: challengeData, error: challengeError } = yield this._challenge({\n                factorId: params.factorId,\n            });\n            if (challengeError) {\n                return { data: null, error: challengeError };\n            }\n            return yield this._verify({\n                factorId: params.factorId,\n                challengeId: challengeData.id,\n                code: params.code,\n            });\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#listFactors}\n     */\n    _listFactors() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { data: { user }, error: userError, } = yield this.getUser();\n            if (userError) {\n                return { data: null, error: userError };\n            }\n            const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n            const totp = factors.filter((factor) => factor.factor_type === 'totp' && factor.status === 'verified');\n            return {\n                data: {\n                    all: factors,\n                    totp,\n                },\n                error: null,\n            };\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n     */\n    _getAuthenticatorAssuranceLevel() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const { data: { session }, error: sessionError, } = yield this.getSession();\n            if (sessionError) {\n                return { data: null, error: sessionError };\n            }\n            if (!session) {\n                return {\n                    data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\n                    error: null,\n                };\n            }\n            const payload = this._decodeJWT(session.access_token);\n            let currentLevel = null;\n            if (payload.aal) {\n                currentLevel = payload.aal;\n            }\n            let nextLevel = currentLevel;\n            const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter((factor) => factor.status === 'verified')) !== null && _b !== void 0 ? _b : [];\n            if (verifiedFactors.length > 0) {\n                nextLevel = 'aal2';\n            }\n            const currentAuthenticationMethods = payload.amr || [];\n            return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}